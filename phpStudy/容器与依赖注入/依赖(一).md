### 先做简单的依赖实现。

- 首先我们有一个到哪儿去的目的地和去那儿的交通方式的接口

```php
<?php
/**
 * Created by PhpStorm.
 * User: liyi
 * Date: 2018/12/17
 * Time: 10:47
 */
namespace App\Http\Controllers\Test;

/**
 * 旅游地点及交通工具接口
 * Interface VehicleInterface
 * @package App\Http\Controllers\Test
 */
interface VehicleInterface
{
    public function goRun();

    public function goToTarget();
}
?>
```

- 然后我们去那儿，用什么去，都是继承这个接口，然后去具体的实现，我们现在先创建：
```php
WalkController
CarController
TrainController
AircraftController
```
这四种控制器，然后在控制器里我们去实现

```php
<?php

namespace App\Http\Controllers\Test;

use App\Http\Controllers\Test\VehicleInterface;

class WalkController implements VehicleInterface
{
    protected $_run;
    protected $_target;

    public function __construct($run,$target)
    {
        $this->_run = $run;
        $this->_target = $target;
    }

    public function goRun()
    {
        // TODO: Implement goRun() method.
        return $this->_run;

    }

    public function goToTarget()
    {
        // TODO: Implement goToTarget() method.
        echo '我要去'.$this->goRun().'了，锻炼自己，我将要'.$this->_target.'过去';
    }
}
?>

<?php

namespace App\Http\Controllers\Test;

use App\Http\Controllers\Test\VehicleInterface;

class CarController implements VehicleInterface
{
    protected $_run;
    protected $_target;

    public function __construct($run,$target)
    {
        $this->_run = $run;
        $this->_target = $target;
    }

    public function goRun()
    {
        // TODO: Implement goRun() method.
        return $this->_run;

    }

    public function goToTarget()
    {
        // TODO: Implement goToTarget() method.
        echo '我要去'.$this->goRun().'了，锻炼自己，我将要'.$this->_target.'过去';
    }
}
?>

<?php

namespace App\Http\Controllers\Test;

use App\Http\Controllers\Test\VehicleInterface;

class TrainController implements VehicleInterface
{
    protected $_run;
    protected $_target;

    public function __construct($run,$target)
    {
        $this->_run = $run;
        $this->_target = $target;
    }

    public function goRun()
    {
        // TODO: Implement goRun() method.
        return $this->_run;

    }

    public function goToTarget()
    {
        // TODO: Implement goToTarget() method.
        echo '我要去'.$this->goRun().'了，锻炼自己，我将要'.$this->_target.'过去';
    }
}
?>

<?php

namespace App\Http\Controllers\Test;

use App\Http\Controllers\Test\VehicleInterface;

class AircraftController implements VehicleInterface
{
    protected $_run;
    protected $_target;

    public function __construct($run,$target)
    {
        $this->_run = $run;
        $this->_target = $target;
    }

    public function goRun()
    {
        // TODO: Implement goRun() method.
        return $this->_run;

    }

    public function goToTarget()
    {
        // TODO: Implement goToTarget() method.
        echo '我要去'.$this->goRun().'了，锻炼自己，我将要'.$this->_target.'过去';
    }
}
?>
```

- 最后我们要在我们的代码中用到这四种交通方式了，也就是我们已经一切准备好了，想好要去那儿玩了，也想好要用什么交通方式去了
```php
<?php

namespace App\Http\Controllers\Test;


class TravelController
{
    public $obj;
    public function __construct()
    {
        $this->obj = new CarController('北京','开汽车');
    }

    public function go()
    {
        $this->obj->goToTarget();
    }
}
?>
```
现在在这里，在`TravelController`这里的构造方法里，我们就首先实例化了`CarController`这个类。也就是我们如果换一种交通方式
就要重新实例化另一个类，要做修改。【修改呀！！！】

其实我们现在这就是一种“依赖”，两个代码之间产生了依赖，在程序中依赖可以理解为一个对象实现某些功能需要其它对象某些功能的支持。
当用new 关键字在一个组件内部实例化一个对象的时候，就解决了一个依赖，但是同时又引入另外一个问题，那就是【耦合】

我们现在的依赖是在类的内部构造函数中固定的写入，当改变的时候，你需要一层一层的找，然后一点一点的改变，这很麻烦。
那么我们有没有可能，我们不在内部固定实例，而转交外部负责呢？答案是当然可以的，【在系统运行期间，将这种依赖关系通过动态注入方式实现】
- 控制反转是将组件间的依赖关系从程序内部提到外部容器来管理
- 依赖注入是指组件的依赖通过外部参数或其它形式注入