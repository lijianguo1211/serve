### psql 中的锁

* 表级锁

`share` 相当于加了读锁，表的内容不能变化，意思是加了锁之后，别人不能修改此表

`exclusive` 相当于加了写锁，别的进程不能读，不能写

`access share` 加了此锁，表名正在修改的数据也允许读取数据

`access exclusive` 意思是即使有多版本的功能，也不许访问数据

`row share` 共享意向锁

`row exclusive` 排它意向锁

`share update exclusive`

`share row exclusive`

**注意** 意向锁之间是不会发生冲突的

* 行级锁

`共享锁`

`排它锁`

* 死锁

发生条件：

1. 互斥条件：事务此时已经持有一个排它锁，在这一段时间，也只能由一个事务加锁占用，此时如果有别的请求想加锁请求，只能排队阻塞等候，只能等第一个事务完城
后释放锁

2. 请求和保持条件：事务已经至少持有一个排它锁，但又提了新的排它锁请求，而该资源上的排它锁已被其它事务占有，此时请求被阻塞，但是自己手上获得的排它锁又
保持不放

3. 不剥夺条件：事务已经获得的锁，在未使用完之前，不能被其它进程剥夺，只能在使用完成时由自己释放

4. 环路等待条件：发生死锁时，必然存在一个事务-资源的环形链，事务集合

* 加表级锁命令

```postgresplsql
lock table [name] [lockmode] [nowait]

-- name 表名

-- lockmode 表锁模式

-- 加关键字 nowait,当无法立即获得锁时，此命令会立即退出并且发出一个错误信息

```

**事务自己的锁是从来不冲突的**

* 行级锁命令

```postgresplsql
select .... for [update|share] [of table_name] [nowait]
```

* 锁的查看，查询视图 `pg_locks`

### **mysql中也有表级锁和行级锁**：而且`mysql`中的是不同的存储引擎对应不同的锁

* `innodb` 行级锁

* `myisam` 表级锁

