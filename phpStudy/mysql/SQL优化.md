### 数据库的优化相关思路

* 数据表
    
    创建数据表的时候，数据类型的选择。可以选择定长的就选择定长的数据。比如：
    
    `tinyint`是1个字节，
    `smallint`是2个字节
    `int`是4个字节，
    `bigint`是8个字节，
    `float`是4个字节，
    `double`是8个字节，
    `char`是定长的（n），
    `varchar`是变长的（n），
    `year`是1个字节，
    `date` 是3个字节，
    `time`是3个字节，
    `timestamp`是4个字节，
    `datetime`是8个字节
    
    也就是说，在创建表的时候，如果我们所有的数据都是定长的类型，那么这个表的所有行的数据大小都是一样的，这样的话在查询的时候也是非常快的。字段在创建
    的时候，比如：
    1. 我们用户表的密码字段，我们知道我们加密后字段的长度是60，那么此时使用`char(60)`就好了，它就是需要60个字节。此时就不需要再去使用
    `varchar(60)`,虽然他们的效果都差不多，都是最多存储60个字符。但是`varchar(60)`所占用的空间就不止60个字节了。而且`char` 类型的字符串检索速
    度要比 `varchar` 类型的快。
    
    2. 我们在创建表的时候，有创建时间和修改时间字段，需要存储时间，按字节来看，使用`timestamp`和`int`都差不多，都是需要4个字节，但是，我们在能使
    用整型的数据的时候，就尽量使用整型。优先级，整型是最大的大佬。

* 数据列
    
第一：数据列按照三范式来说：
    每个字段要拆分到最小，到不可拆分的状态。
    每个表都要有一个主键，非主键要依赖于主键。就是每张表只表达一个声音，说一不二的，
    每个表的非主键字段不可相互依赖，也就是每列的数据都需要和主键有直接的依赖关系，而不存在传递依赖。
    
第二：常用字段和不常用字段分开存储，也就是常用字段存储在一个表里，然后非常使用字段通过主键进行关联存储到另外一张表。
         字段的值杜绝存储`null`值。也就是创建表列的时候加上`not null`这个限制。虽然`mysql`对null做了优化，但是有时还会在我们`is null`中，使
         索引失效，从而影响我们的查询效率。
         
第三：选择索引方法（在mysql中可以选择`b-tree`和`hash`）这两种索引，所以还需要根据查询的条件作出选择。
         比如，我们查询的时候没有范围查询，就只有`=`这样的查询，那么索引自然选择的是`hash`索引。
         同时，我们有范围查询。`> >= = < <= like`这个时候，我们最好的选择就是`b-tree`索引。     
    
* 数据SQL语句
    
**SQL语句可控:**
    
第一：查询数据的时候，尽量查询我们需要得到的列，我们需要使用到的列，
        
第二：查询语句中不要出现函数运算，或者运算不在字段上做，比如在`where`后面做，而不是`where`之前
        
第三：查询连续出现的字段值的时候，就可以使用`between`,比如我们查询ID为6-10的记录，那么我们就可以这样写：   
  
```mysql
select name from users where id between 6 and 10;  
     
-- 这样的效率就比你写`where id = 6 and id = 7 and id = 8 and id = 9 and id = 10`要好，不管是写法上，或者是美观上，或者是效率上都是如此：
```

第四：其实和第三条要注意的差不多，如果说第三条是对`and`的优化，那么这一个就是对`or`的优化，比如：

```mysql
select name from users where id in (6,8,12,15);

-- or的写法

select name from users where id =6 or id = 8 or id = 12 or id = 15;
```
`or`的写法也是丑，而且繁杂，还容易写错，在数据多的时候，特别容易在不注意的时候出现各种问题，当然最严重的还是在你使用`or`查询时，索引也会导致失效。最
严重的就是导致全表扫描了。或者我们在使用`or`的时候，我们还可以使用`union`来做替代

```mysql
select name from users where id = 5
union 
select name from users where id = 10;
```

当然这里使用`union`还有一点需要注意，那就是在得到两条数据一样的时候，它会自己合并，也就是最后返回的结果只有一条，当然，你如果不想它合并的话，那就使用
`union all`
    

